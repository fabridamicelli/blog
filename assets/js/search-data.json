{
  
    
        "post0": {
            "title": "Bingo Percolation",
            "content": "Let’s play bingo percolation! . Disclaimer: what you’re about to read might be somehow trivial and analytically solvable after a bit of combinatorics-probabilities gymnastics. If that already sounds boring, imagine actually going through it with pen and paper. Let’s see what Python can do for us. . edit: I just learned about this post. Vincent approaches it from a complementary, analytical perspective, so check it out. . Disclaimer 2: this is not about coffee. I’m sorry too. . The story . So one day we where playing champagne-bingo because.. why not? It’s a pretty straight forward game. If you know bingo, it’s the same, but! everyone has a glass of champagne and is supposed to take a sip if the drawn number is not on his/her ticket. Easy. You can do the math for yourself about the number of times you end up having to drink..but that’s not the point here. . Percolation . Percolation refers to a whole world of interesting stuff, ranging from coffee brewing to epidemics spreading and everything in between. But it suffices here to know that the deal is about trying to understand phase transitions in a particular system. That means, characterizing and being able to predict a qualitative change in the behaviour of some macroscopic property of the system. For example, let’s say we have a bunch of isolated new users of a new social network. Now we start connecting them randomly, like getting them to be friends but without any criterion rather than a certain fixed probability of getting connected. Percolation theory helps us predicting what is the minimum amount of friends per person that we need (on average) in order to have a social network that is connected, i.e., in which everybody is reachable by taking a finite number of hops in the network. Pretty useful, right? . Back to the game . It turns out we did not stop playing when we where supposed to, i.e., whenever someone won (got bingo) just for the sake of.. you know.. just having fun a bit longer. . And my observation was that, after a long period of people doing little more than drinking number after number (pretty hard life), a rather abrupt transition seemed to occur and folks were getting (first) lines (and then) bingo more and more often. In other words, as time passed (numbers got drawn), the probability that someone would jump up, scream out loud “line” or “bingo” while performing a nice hula dance seemed to be higher and higher. Yes, you got it, a non-linear transition. Yes, like a percolation. To be more precise, a bingo-percolation! . So let’s see if that is actually the case. . Bingo . There are a couple of variations to it, but the one we played looked like this: . 75 balls numbered 1 to 75 | each ticket has 25 numbers (5x5 grid), each column having the numbers: (B) first: 1-15 | (I) second: 16-30 | (N) third: 31-45 | (G) fourth: 46-60 | (O) fifth: 61-75 | . | “line”: full horizontal/vertical/diagonal line marked * | “bingo”: full ticket marked | . (Minutia: For the “lines” we only track the occurrence of at least one line per ticket, since there was a price for only the first one getting it. So after a player gets a line, she will afterwards always count as simply having at least one line, independently from the fact that she can get a different line in the future.) . On to the code! . Requirements . numpy | matplotlib | seaborn | . # We need # - tickets # - number drawer # - ticket marker # - ticket checker # - game runner def make_tickets(n_tickets=10): &#39;&#39;&#39; Return 3D array - stack of n_tickets. &#39;&#39;&#39; tickets = [ np.transpose([ sorted(np.random.choice(row, size=5, replace=False)) for row in np.arange(1, 76).reshape(5, 15)]) for _ in range(n_tickets) ] if n_tickets == 1: return np.array(tickets)[0] return np.array(tickets) def draw_allnumbers(): &#39;&#39;&#39;Draw the numbers for the whole game at once&#39;&#39;&#39; return np.random.choice(range(1, 76), size=75, replace=False) def mark_ticket(ticket, number): &#39;&#39;&#39; Modify ticket putting a mark (0) if number is on it. &#39;&#39;&#39; ticket[ticket == number] = 0 return ticket def check_line(ticket): &#39;&#39;&#39; Return: (bool) ticket has at least one of the valid lines marked. &#39;&#39;&#39; line = any([ sum([np.all(row == 0) for row in ticket]) &gt; 0, # horizontal sum([np.all(row == 0) for row in ticket.T]) &gt; 0, # vertical np.all(np.diag(ticket) == 0), # diagonals np.all(np.diag(np.fliplr(ticket)) == 0) ]) return line def check_bingo(ticket): &#39;&#39;&#39;Return True if ticket has bingo (all numbers are marked)&#39;&#39;&#39; return np.all(ticket == 0) def play_game(n_players=100): # Initialize game tickets = make_tickets(n_players) numbers = draw_allnumbers() # Track number of lines/bingos after each number drawn lines = np.zeros_like(numbers) bingos = np.zeros_like(numbers) # Play rounds, number by number for i, number in enumerate(numbers): for ticket in tickets: mark_ticket(ticket, number) # Check how many players got have at least one line or bingo lines[i] += check_line(ticket) bingos[i] += check_bingo(ticket) return lines, bingos . That’s it! . So we can run the script bingo.py . python bingo.py . The output figure shows the results of 100 rounds of the game, played by 100 players. Individual traces correspond to each run, while the bold lines depict the average trace for each case. . . In fact, we see a sharp transition both in the proportion of players with at least one line as well as in the proportion of players with bingo. . Lo and behold, the curves kind of agree with the initial intuition :) . All the code can be found here. . . Any bugs, questions, comments, suggestions? Ping me on twitter or drop me an e-mail. .",
            "url": "https://fabridamicelli.github.io/blog/python/probabilities/computational-stats/2019/10/01/bingo-percolation.html",
            "relUrl": "/python/probabilities/computational-stats/2019/10/01/bingo-percolation.html",
            "date": " • Oct 1, 2019"
        }
        
    
  

  
  

  
      ,"page1": {
          "title": "about",
          "content": "Hi! I’m Fabrizio, a PhD Student at the Institute of Computational Neuroscience in Hamburg (Germany). Check out research and career to learn a bit more about that. . More details coming soon! .",
          "url": "https://fabridamicelli.github.io/blog/about/",
          "relUrl": "/about/",
          "date": ""
      }
      
  

  
      ,"page2": {
          "title": "career",
          "content": "Coming very, very soon! .",
          "url": "https://fabridamicelli.github.io/blog/career/",
          "relUrl": "/career/",
          "date": ""
      }
      
  

  
      ,"page3": {
          "title": "code",
          "content": "More details coming soon. For the time being, you can check out my repo here. .",
          "url": "https://fabridamicelli.github.io/blog/code/",
          "relUrl": "/code/",
          "date": ""
      }
      
  

  

  
      ,"page5": {
          "title": "links",
          "content": "A list of cool resources out there – coming soon! .",
          "url": "https://fabridamicelli.github.io/blog/links/",
          "relUrl": "/links/",
          "date": ""
      }
      
  

  
      ,"page6": {
          "title": "research",
          "content": "Coming very, very soon! .",
          "url": "https://fabridamicelli.github.io/blog/research/",
          "relUrl": "/research/",
          "date": ""
      }
      
  

  
  

  

  
  

  

  
  

  
  

  
  

  
      ,"page14": {
          "title": "",
          "content": "Sitemap: {{ “sitemap.xml” | absolute_url }} | .",
          "url": "https://fabridamicelli.github.io/blog/robots.txt",
          "relUrl": "/robots.txt",
          "date": ""
      }
      
  

}